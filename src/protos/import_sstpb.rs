// This file is generated by rust-protobuf 2.8.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `import_sstpb.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_0;

#[derive(PartialEq,Clone,Default)]
pub struct SwitchModeRequest {
    // message fields
    pub mode: SwitchMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwitchModeRequest {
    fn default() -> &'a SwitchModeRequest {
        <SwitchModeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SwitchModeRequest {
    pub fn new() -> SwitchModeRequest {
        ::std::default::Default::default()
    }

    // .import_sstpb.SwitchMode mode = 1;


    pub fn get_mode(&self) -> SwitchMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = SwitchMode::Normal;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: SwitchMode) {
        self.mode = v;
    }
}

impl ::protobuf::Message for SwitchModeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.mode = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mode != SwitchMode::Normal {
            my_size += ::protobuf::rt::enum_size(1, self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.mode != SwitchMode::Normal {
            os.write_enum(1, self.mode.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwitchModeRequest {
        SwitchModeRequest::new()
    }

    fn default_instance() -> &'static SwitchModeRequest {
        static mut instance: ::protobuf::lazy::Lazy<SwitchModeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SwitchModeRequest,
        };
        unsafe {
            instance.get(SwitchModeRequest::new)
        }
    }
}

impl ::protobuf::Clear for SwitchModeRequest {
    fn clear(&mut self) {
        self.mode = SwitchMode::Normal;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for SwitchModeRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.mode, "mode", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for SwitchModeRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.mode, "mode", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchModeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SwitchModeResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwitchModeResponse {
    fn default() -> &'a SwitchModeResponse {
        <SwitchModeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SwitchModeResponse {
    pub fn new() -> SwitchModeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SwitchModeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwitchModeResponse {
        SwitchModeResponse::new()
    }

    fn default_instance() -> &'static SwitchModeResponse {
        static mut instance: ::protobuf::lazy::Lazy<SwitchModeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SwitchModeResponse,
        };
        unsafe {
            instance.get(SwitchModeResponse::new)
        }
    }
}

impl ::protobuf::Clear for SwitchModeResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for SwitchModeResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
    }
}
impl ::std::fmt::Debug for SwitchModeResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        Ok(())
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchModeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Range {
    // message fields
    pub start: ::std::vec::Vec<u8>,
    pub end: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Range {
    fn default() -> &'a Range {
        <Range as ::protobuf::Message>::default_instance()
    }
}

impl Range {
    pub fn new() -> Range {
        ::std::default::Default::default()
    }

    // bytes start = 1;


    pub fn get_start(&self) -> &[u8] {
        &self.start
    }
    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: ::std::vec::Vec<u8>) {
        self.start = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start
    }

    // Take field
    pub fn take_start(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start, ::std::vec::Vec::new())
    }

    // bytes end = 2;


    pub fn get_end(&self) -> &[u8] {
        &self.end
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: ::std::vec::Vec<u8>) {
        self.end = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end
    }

    // Take field
    pub fn take_end(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Range {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.start.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.start);
        }
        if !self.end.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.end);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.start.is_empty() {
            os.write_bytes(1, &self.start)?;
        }
        if !self.end.is_empty() {
            os.write_bytes(2, &self.end)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Range {
        Range::new()
    }

    fn default_instance() -> &'static Range {
        static mut instance: ::protobuf::lazy::Lazy<Range> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Range,
        };
        unsafe {
            instance.get(Range::new)
        }
    }
}

impl ::protobuf::Clear for Range {
    fn clear(&mut self) {
        self.start.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Range {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.start, "start", buf);
        ::protobuf::PbPrint::fmt(&self.end, "end", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Range {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.start, "start", &mut s);
        ::protobuf::PbPrint::fmt(&self.end, "end", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Range {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SstMeta {
    // message fields
    pub uuid: ::std::vec::Vec<u8>,
    pub range: ::protobuf::SingularPtrField<Range>,
    pub crc32: u32,
    pub length: u64,
    pub cf_name: ::std::string::String,
    pub region_id: u64,
    pub region_epoch: ::protobuf::SingularPtrField<super::metapb::RegionEpoch>,
    pub end_key_exclusive: bool,
    pub total_kvs: u64,
    pub total_bytes: u64,
    pub api_version: super::kvrpcpb::ApiVersion,
    pub cipher_iv: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SstMeta {
    fn default() -> &'a SstMeta {
        <SstMeta as ::protobuf::Message>::default_instance()
    }
}

impl SstMeta {
    pub fn new() -> SstMeta {
        ::std::default::Default::default()
    }

    // bytes uuid = 1;


    pub fn get_uuid(&self) -> &[u8] {
        &self.uuid
    }
    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.uuid, ::std::vec::Vec::new())
    }

    // .import_sstpb.Range range = 2;


    pub fn get_range(&self) -> &Range {
        self.range.as_ref().unwrap_or_else(|| Range::default_instance())
    }
    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: Range) {
        self.range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&mut self) -> &mut Range {
        if self.range.is_none() {
            self.range.set_default();
        }
        self.range.as_mut().unwrap()
    }

    // Take field
    pub fn take_range(&mut self) -> Range {
        self.range.take().unwrap_or_else(|| Range::new())
    }

    // uint32 crc32 = 3;


    pub fn get_crc32(&self) -> u32 {
        self.crc32
    }
    pub fn clear_crc32(&mut self) {
        self.crc32 = 0;
    }

    // Param is passed by value, moved
    pub fn set_crc32(&mut self, v: u32) {
        self.crc32 = v;
    }

    // uint64 length = 4;


    pub fn get_length(&self) -> u64 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = v;
    }

    // string cf_name = 5;


    pub fn get_cf_name(&self) -> &str {
        &self.cf_name
    }
    pub fn clear_cf_name(&mut self) {
        self.cf_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf_name(&mut self, v: ::std::string::String) {
        self.cf_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf_name(&mut self) -> &mut ::std::string::String {
        &mut self.cf_name
    }

    // Take field
    pub fn take_cf_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf_name, ::std::string::String::new())
    }

    // uint64 region_id = 6;


    pub fn get_region_id(&self) -> u64 {
        self.region_id
    }
    pub fn clear_region_id(&mut self) {
        self.region_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_region_id(&mut self, v: u64) {
        self.region_id = v;
    }

    // .metapb.RegionEpoch region_epoch = 7;


    pub fn get_region_epoch(&self) -> &super::metapb::RegionEpoch {
        self.region_epoch.as_ref().unwrap_or_else(|| super::metapb::RegionEpoch::default_instance())
    }
    pub fn clear_region_epoch(&mut self) {
        self.region_epoch.clear();
    }

    pub fn has_region_epoch(&self) -> bool {
        self.region_epoch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_epoch(&mut self, v: super::metapb::RegionEpoch) {
        self.region_epoch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_epoch(&mut self) -> &mut super::metapb::RegionEpoch {
        if self.region_epoch.is_none() {
            self.region_epoch.set_default();
        }
        self.region_epoch.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_epoch(&mut self) -> super::metapb::RegionEpoch {
        self.region_epoch.take().unwrap_or_else(|| super::metapb::RegionEpoch::new())
    }

    // bool end_key_exclusive = 8;


    pub fn get_end_key_exclusive(&self) -> bool {
        self.end_key_exclusive
    }
    pub fn clear_end_key_exclusive(&mut self) {
        self.end_key_exclusive = false;
    }

    // Param is passed by value, moved
    pub fn set_end_key_exclusive(&mut self, v: bool) {
        self.end_key_exclusive = v;
    }

    // uint64 total_kvs = 9;


    pub fn get_total_kvs(&self) -> u64 {
        self.total_kvs
    }
    pub fn clear_total_kvs(&mut self) {
        self.total_kvs = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_kvs(&mut self, v: u64) {
        self.total_kvs = v;
    }

    // uint64 total_bytes = 10;


    pub fn get_total_bytes(&self) -> u64 {
        self.total_bytes
    }
    pub fn clear_total_bytes(&mut self) {
        self.total_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_bytes(&mut self, v: u64) {
        self.total_bytes = v;
    }

    // .kvrpcpb.APIVersion api_version = 11;


    pub fn get_api_version(&self) -> super::kvrpcpb::ApiVersion {
        self.api_version
    }
    pub fn clear_api_version(&mut self) {
        self.api_version = super::kvrpcpb::ApiVersion::V1;
    }

    // Param is passed by value, moved
    pub fn set_api_version(&mut self, v: super::kvrpcpb::ApiVersion) {
        self.api_version = v;
    }

    // bytes cipher_iv = 12;


    pub fn get_cipher_iv(&self) -> &[u8] {
        &self.cipher_iv
    }
    pub fn clear_cipher_iv(&mut self) {
        self.cipher_iv.clear();
    }

    // Param is passed by value, moved
    pub fn set_cipher_iv(&mut self, v: ::std::vec::Vec<u8>) {
        self.cipher_iv = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cipher_iv(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.cipher_iv
    }

    // Take field
    pub fn take_cipher_iv(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.cipher_iv, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SstMeta {
    fn is_initialized(&self) -> bool {
        for v in &self.range {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.region_epoch {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.uuid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.range)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.crc32 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf_name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.region_id = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_epoch)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.end_key_exclusive = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_kvs = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_bytes = tmp;
                },
                11 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.api_version = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.cipher_iv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.uuid);
        }
        if let Some(ref v) = self.range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.crc32 != 0 {
            my_size += ::protobuf::rt::value_size(3, self.crc32, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(4, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.cf_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.cf_name);
        }
        if self.region_id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.region_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.region_epoch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.end_key_exclusive != false {
            my_size += 2;
        }
        if self.total_kvs != 0 {
            my_size += ::protobuf::rt::value_size(9, self.total_kvs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_bytes != 0 {
            my_size += ::protobuf::rt::value_size(10, self.total_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.api_version != super::kvrpcpb::ApiVersion::V1 {
            my_size += ::protobuf::rt::enum_size(11, self.api_version);
        }
        if !self.cipher_iv.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.cipher_iv);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.uuid.is_empty() {
            os.write_bytes(1, &self.uuid)?;
        }
        if let Some(ref v) = self.range.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.crc32 != 0 {
            os.write_uint32(3, self.crc32)?;
        }
        if self.length != 0 {
            os.write_uint64(4, self.length)?;
        }
        if !self.cf_name.is_empty() {
            os.write_string(5, &self.cf_name)?;
        }
        if self.region_id != 0 {
            os.write_uint64(6, self.region_id)?;
        }
        if let Some(ref v) = self.region_epoch.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.end_key_exclusive != false {
            os.write_bool(8, self.end_key_exclusive)?;
        }
        if self.total_kvs != 0 {
            os.write_uint64(9, self.total_kvs)?;
        }
        if self.total_bytes != 0 {
            os.write_uint64(10, self.total_bytes)?;
        }
        if self.api_version != super::kvrpcpb::ApiVersion::V1 {
            os.write_enum(11, self.api_version.value())?;
        }
        if !self.cipher_iv.is_empty() {
            os.write_bytes(12, &self.cipher_iv)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SstMeta {
        SstMeta::new()
    }

    fn default_instance() -> &'static SstMeta {
        static mut instance: ::protobuf::lazy::Lazy<SstMeta> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SstMeta,
        };
        unsafe {
            instance.get(SstMeta::new)
        }
    }
}

impl ::protobuf::Clear for SstMeta {
    fn clear(&mut self) {
        self.uuid.clear();
        self.range.clear();
        self.crc32 = 0;
        self.length = 0;
        self.cf_name.clear();
        self.region_id = 0;
        self.region_epoch.clear();
        self.end_key_exclusive = false;
        self.total_kvs = 0;
        self.total_bytes = 0;
        self.api_version = super::kvrpcpb::ApiVersion::V1;
        self.cipher_iv.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for SstMeta {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.uuid, "uuid", buf);
        ::protobuf::PbPrint::fmt(&self.range, "range", buf);
        ::protobuf::PbPrint::fmt(&self.crc32, "crc32", buf);
        ::protobuf::PbPrint::fmt(&self.length, "length", buf);
        ::protobuf::PbPrint::fmt(&self.cf_name, "cf_name", buf);
        ::protobuf::PbPrint::fmt(&self.region_id, "region_id", buf);
        ::protobuf::PbPrint::fmt(&self.region_epoch, "region_epoch", buf);
        ::protobuf::PbPrint::fmt(&self.end_key_exclusive, "end_key_exclusive", buf);
        ::protobuf::PbPrint::fmt(&self.total_kvs, "total_kvs", buf);
        ::protobuf::PbPrint::fmt(&self.total_bytes, "total_bytes", buf);
        ::protobuf::PbPrint::fmt(&self.api_version, "api_version", buf);
        ::protobuf::PbPrint::fmt(&self.cipher_iv, "cipher_iv", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for SstMeta {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.uuid, "uuid", &mut s);
        ::protobuf::PbPrint::fmt(&self.range, "range", &mut s);
        ::protobuf::PbPrint::fmt(&self.crc32, "crc32", &mut s);
        ::protobuf::PbPrint::fmt(&self.length, "length", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf_name, "cf_name", &mut s);
        ::protobuf::PbPrint::fmt(&self.region_id, "region_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.region_epoch, "region_epoch", &mut s);
        ::protobuf::PbPrint::fmt(&self.end_key_exclusive, "end_key_exclusive", &mut s);
        ::protobuf::PbPrint::fmt(&self.total_kvs, "total_kvs", &mut s);
        ::protobuf::PbPrint::fmt(&self.total_bytes, "total_bytes", &mut s);
        ::protobuf::PbPrint::fmt(&self.api_version, "api_version", &mut s);
        ::protobuf::PbPrint::fmt(&self.cipher_iv, "cipher_iv", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for SstMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RewriteRule {
    // message fields
    pub old_key_prefix: ::std::vec::Vec<u8>,
    pub new_key_prefix: ::std::vec::Vec<u8>,
    pub new_timestamp: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RewriteRule {
    fn default() -> &'a RewriteRule {
        <RewriteRule as ::protobuf::Message>::default_instance()
    }
}

impl RewriteRule {
    pub fn new() -> RewriteRule {
        ::std::default::Default::default()
    }

    // bytes old_key_prefix = 1;


    pub fn get_old_key_prefix(&self) -> &[u8] {
        &self.old_key_prefix
    }
    pub fn clear_old_key_prefix(&mut self) {
        self.old_key_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_old_key_prefix(&mut self, v: ::std::vec::Vec<u8>) {
        self.old_key_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_old_key_prefix(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.old_key_prefix
    }

    // Take field
    pub fn take_old_key_prefix(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.old_key_prefix, ::std::vec::Vec::new())
    }

    // bytes new_key_prefix = 2;


    pub fn get_new_key_prefix(&self) -> &[u8] {
        &self.new_key_prefix
    }
    pub fn clear_new_key_prefix(&mut self) {
        self.new_key_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_new_key_prefix(&mut self, v: ::std::vec::Vec<u8>) {
        self.new_key_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_key_prefix(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.new_key_prefix
    }

    // Take field
    pub fn take_new_key_prefix(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.new_key_prefix, ::std::vec::Vec::new())
    }

    // uint64 new_timestamp = 3;


    pub fn get_new_timestamp(&self) -> u64 {
        self.new_timestamp
    }
    pub fn clear_new_timestamp(&mut self) {
        self.new_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_new_timestamp(&mut self, v: u64) {
        self.new_timestamp = v;
    }
}

impl ::protobuf::Message for RewriteRule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.old_key_prefix)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.new_key_prefix)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.new_timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.old_key_prefix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.old_key_prefix);
        }
        if !self.new_key_prefix.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.new_key_prefix);
        }
        if self.new_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.new_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.old_key_prefix.is_empty() {
            os.write_bytes(1, &self.old_key_prefix)?;
        }
        if !self.new_key_prefix.is_empty() {
            os.write_bytes(2, &self.new_key_prefix)?;
        }
        if self.new_timestamp != 0 {
            os.write_uint64(3, self.new_timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RewriteRule {
        RewriteRule::new()
    }

    fn default_instance() -> &'static RewriteRule {
        static mut instance: ::protobuf::lazy::Lazy<RewriteRule> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RewriteRule,
        };
        unsafe {
            instance.get(RewriteRule::new)
        }
    }
}

impl ::protobuf::Clear for RewriteRule {
    fn clear(&mut self) {
        self.old_key_prefix.clear();
        self.new_key_prefix.clear();
        self.new_timestamp = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RewriteRule {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.old_key_prefix, "old_key_prefix", buf);
        ::protobuf::PbPrint::fmt(&self.new_key_prefix, "new_key_prefix", buf);
        ::protobuf::PbPrint::fmt(&self.new_timestamp, "new_timestamp", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RewriteRule {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.old_key_prefix, "old_key_prefix", &mut s);
        ::protobuf::PbPrint::fmt(&self.new_key_prefix, "new_key_prefix", &mut s);
        ::protobuf::PbPrint::fmt(&self.new_timestamp, "new_timestamp", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RewriteRule {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UploadRequest {
    // message oneof groups
    pub chunk: ::std::option::Option<UploadRequest_oneof_chunk>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UploadRequest {
    fn default() -> &'a UploadRequest {
        <UploadRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq)]
pub enum UploadRequest_oneof_chunk {
    Meta(SstMeta),
    Data(::std::vec::Vec<u8>),
}

impl ::protobuf::PbPrint for UploadRequest_oneof_chunk {
    fn fmt(&self, name: &str, buf: &mut String) {
        match self {
            UploadRequest_oneof_chunk::Meta(v) => ::protobuf::PbPrint::fmt(v, name, buf),
            UploadRequest_oneof_chunk::Data(v) => ::protobuf::PbPrint::fmt(v, name, buf),
        }
    }
}

impl UploadRequest {
    pub fn new() -> UploadRequest {
        ::std::default::Default::default()
    }

    // .import_sstpb.SSTMeta meta = 1;


    pub fn get_meta(&self) -> &SstMeta {
        match self.chunk {
            ::std::option::Option::Some(UploadRequest_oneof_chunk::Meta(ref v)) => v,
            _ => SstMeta::default_instance(),
        }
    }
    pub fn clear_meta(&mut self) {
        self.chunk = ::std::option::Option::None;
    }

    pub fn has_meta(&self) -> bool {
        match self.chunk {
            ::std::option::Option::Some(UploadRequest_oneof_chunk::Meta(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_meta(&mut self, v: SstMeta) {
        self.chunk = ::std::option::Option::Some(UploadRequest_oneof_chunk::Meta(v))
    }

    // Mutable pointer to the field.
    pub fn mut_meta(&mut self) -> &mut SstMeta {
        if let ::std::option::Option::Some(UploadRequest_oneof_chunk::Meta(_)) = self.chunk {
        } else {
            self.chunk = ::std::option::Option::Some(UploadRequest_oneof_chunk::Meta(SstMeta::new()));
        }
        match self.chunk {
            ::std::option::Option::Some(UploadRequest_oneof_chunk::Meta(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_meta(&mut self) -> SstMeta {
        if self.has_meta() {
            match self.chunk.take() {
                ::std::option::Option::Some(UploadRequest_oneof_chunk::Meta(v)) => v,
                _ => panic!(),
            }
        } else {
            SstMeta::new()
        }
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        match self.chunk {
            ::std::option::Option::Some(UploadRequest_oneof_chunk::Data(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.chunk = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        match self.chunk {
            ::std::option::Option::Some(UploadRequest_oneof_chunk::Data(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.chunk = ::std::option::Option::Some(UploadRequest_oneof_chunk::Data(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(UploadRequest_oneof_chunk::Data(_)) = self.chunk {
        } else {
            self.chunk = ::std::option::Option::Some(UploadRequest_oneof_chunk::Data(::std::vec::Vec::new()));
        }
        match self.chunk {
            ::std::option::Option::Some(UploadRequest_oneof_chunk::Data(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_data() {
            match self.chunk.take() {
                ::std::option::Option::Some(UploadRequest_oneof_chunk::Data(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for UploadRequest {
    fn is_initialized(&self) -> bool {
        if let Some(UploadRequest_oneof_chunk::Meta(ref v)) = self.chunk {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chunk = ::std::option::Option::Some(UploadRequest_oneof_chunk::Meta(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chunk = ::std::option::Option::Some(UploadRequest_oneof_chunk::Data(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.chunk {
            match v {
                &UploadRequest_oneof_chunk::Meta(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &UploadRequest_oneof_chunk::Data(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.chunk {
            match v {
                &UploadRequest_oneof_chunk::Meta(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &UploadRequest_oneof_chunk::Data(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadRequest {
        UploadRequest::new()
    }

    fn default_instance() -> &'static UploadRequest {
        static mut instance: ::protobuf::lazy::Lazy<UploadRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UploadRequest,
        };
        unsafe {
            instance.get(UploadRequest::new)
        }
    }
}

impl ::protobuf::Clear for UploadRequest {
    fn clear(&mut self) {
        self.chunk = ::std::option::Option::None;
        self.chunk = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for UploadRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.chunk, "chunk", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for UploadRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.chunk, "chunk", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UploadResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UploadResponse {
    fn default() -> &'a UploadResponse {
        <UploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl UploadResponse {
    pub fn new() -> UploadResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UploadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadResponse {
        UploadResponse::new()
    }

    fn default_instance() -> &'static UploadResponse {
        static mut instance: ::protobuf::lazy::Lazy<UploadResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UploadResponse,
        };
        unsafe {
            instance.get(UploadResponse::new)
        }
    }
}

impl ::protobuf::Clear for UploadResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for UploadResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
    }
}
impl ::std::fmt::Debug for UploadResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        Ok(())
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IngestRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<super::kvrpcpb::Context>,
    pub sst: ::protobuf::SingularPtrField<SstMeta>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IngestRequest {
    fn default() -> &'a IngestRequest {
        <IngestRequest as ::protobuf::Message>::default_instance()
    }
}

impl IngestRequest {
    pub fn new() -> IngestRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &super::kvrpcpb::Context {
        self.context.as_ref().unwrap_or_else(|| super::kvrpcpb::Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: super::kvrpcpb::Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut super::kvrpcpb::Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> super::kvrpcpb::Context {
        self.context.take().unwrap_or_else(|| super::kvrpcpb::Context::new())
    }

    // .import_sstpb.SSTMeta sst = 2;


    pub fn get_sst(&self) -> &SstMeta {
        self.sst.as_ref().unwrap_or_else(|| SstMeta::default_instance())
    }
    pub fn clear_sst(&mut self) {
        self.sst.clear();
    }

    pub fn has_sst(&self) -> bool {
        self.sst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sst(&mut self, v: SstMeta) {
        self.sst = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sst(&mut self) -> &mut SstMeta {
        if self.sst.is_none() {
            self.sst.set_default();
        }
        self.sst.as_mut().unwrap()
    }

    // Take field
    pub fn take_sst(&mut self) -> SstMeta {
        self.sst.take().unwrap_or_else(|| SstMeta::new())
    }
}

impl ::protobuf::Message for IngestRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sst {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sst)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sst.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sst.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IngestRequest {
        IngestRequest::new()
    }

    fn default_instance() -> &'static IngestRequest {
        static mut instance: ::protobuf::lazy::Lazy<IngestRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IngestRequest,
        };
        unsafe {
            instance.get(IngestRequest::new)
        }
    }
}

impl ::protobuf::Clear for IngestRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.sst.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for IngestRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.sst, "sst", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for IngestRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.sst, "sst", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngestRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiIngestRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<super::kvrpcpb::Context>,
    pub ssts: ::protobuf::RepeatedField<SstMeta>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MultiIngestRequest {
    fn default() -> &'a MultiIngestRequest {
        <MultiIngestRequest as ::protobuf::Message>::default_instance()
    }
}

impl MultiIngestRequest {
    pub fn new() -> MultiIngestRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &super::kvrpcpb::Context {
        self.context.as_ref().unwrap_or_else(|| super::kvrpcpb::Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: super::kvrpcpb::Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut super::kvrpcpb::Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> super::kvrpcpb::Context {
        self.context.take().unwrap_or_else(|| super::kvrpcpb::Context::new())
    }

    // repeated .import_sstpb.SSTMeta ssts = 2;


    pub fn get_ssts(&self) -> &[SstMeta] {
        &self.ssts
    }
    pub fn clear_ssts(&mut self) {
        self.ssts.clear();
    }

    // Param is passed by value, moved
    pub fn set_ssts(&mut self, v: ::protobuf::RepeatedField<SstMeta>) {
        self.ssts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ssts(&mut self) -> &mut ::protobuf::RepeatedField<SstMeta> {
        &mut self.ssts
    }

    // Take field
    pub fn take_ssts(&mut self) -> ::protobuf::RepeatedField<SstMeta> {
        ::std::mem::replace(&mut self.ssts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MultiIngestRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ssts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ssts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ssts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ssts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiIngestRequest {
        MultiIngestRequest::new()
    }

    fn default_instance() -> &'static MultiIngestRequest {
        static mut instance: ::protobuf::lazy::Lazy<MultiIngestRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MultiIngestRequest,
        };
        unsafe {
            instance.get(MultiIngestRequest::new)
        }
    }
}

impl ::protobuf::Clear for MultiIngestRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.ssts.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for MultiIngestRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.ssts, "ssts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for MultiIngestRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.ssts, "ssts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiIngestRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IngestResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IngestResponse {
    fn default() -> &'a IngestResponse {
        <IngestResponse as ::protobuf::Message>::default_instance()
    }
}

impl IngestResponse {
    pub fn new() -> IngestResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error error = 1;


    pub fn get_error(&self) -> &super::errorpb::Error {
        self.error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: super::errorpb::Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut super::errorpb::Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> super::errorpb::Error {
        self.error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }
}

impl ::protobuf::Message for IngestResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IngestResponse {
        IngestResponse::new()
    }

    fn default_instance() -> &'static IngestResponse {
        static mut instance: ::protobuf::lazy::Lazy<IngestResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IngestResponse,
        };
        unsafe {
            instance.get(IngestResponse::new)
        }
    }
}

impl ::protobuf::Clear for IngestResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for IngestResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for IngestResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for IngestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactRequest {
    // message fields
    pub range: ::protobuf::SingularPtrField<Range>,
    pub output_level: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactRequest {
    fn default() -> &'a CompactRequest {
        <CompactRequest as ::protobuf::Message>::default_instance()
    }
}

impl CompactRequest {
    pub fn new() -> CompactRequest {
        ::std::default::Default::default()
    }

    // .import_sstpb.Range range = 1;


    pub fn get_range(&self) -> &Range {
        self.range.as_ref().unwrap_or_else(|| Range::default_instance())
    }
    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: Range) {
        self.range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&mut self) -> &mut Range {
        if self.range.is_none() {
            self.range.set_default();
        }
        self.range.as_mut().unwrap()
    }

    // Take field
    pub fn take_range(&mut self) -> Range {
        self.range.take().unwrap_or_else(|| Range::new())
    }

    // int32 output_level = 2;


    pub fn get_output_level(&self) -> i32 {
        self.output_level
    }
    pub fn clear_output_level(&mut self) {
        self.output_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_level(&mut self, v: i32) {
        self.output_level = v;
    }
}

impl ::protobuf::Message for CompactRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.range)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.output_level = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.output_level != 0 {
            my_size += ::protobuf::rt::value_size(2, self.output_level, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.range.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.output_level != 0 {
            os.write_int32(2, self.output_level)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactRequest {
        CompactRequest::new()
    }

    fn default_instance() -> &'static CompactRequest {
        static mut instance: ::protobuf::lazy::Lazy<CompactRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompactRequest,
        };
        unsafe {
            instance.get(CompactRequest::new)
        }
    }
}

impl ::protobuf::Clear for CompactRequest {
    fn clear(&mut self) {
        self.range.clear();
        self.output_level = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CompactRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.range, "range", buf);
        ::protobuf::PbPrint::fmt(&self.output_level, "output_level", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for CompactRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.range, "range", &mut s);
        ::protobuf::PbPrint::fmt(&self.output_level, "output_level", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompactResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompactResponse {
    fn default() -> &'a CompactResponse {
        <CompactResponse as ::protobuf::Message>::default_instance()
    }
}

impl CompactResponse {
    pub fn new() -> CompactResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CompactResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompactResponse {
        CompactResponse::new()
    }

    fn default_instance() -> &'static CompactResponse {
        static mut instance: ::protobuf::lazy::Lazy<CompactResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompactResponse,
        };
        unsafe {
            instance.get(CompactResponse::new)
        }
    }
}

impl ::protobuf::Clear for CompactResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for CompactResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
    }
}
impl ::std::fmt::Debug for CompactResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        Ok(())
    }
}

impl ::protobuf::reflect::ProtobufValue for CompactResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownloadRequest {
    // message fields
    pub sst: ::protobuf::SingularPtrField<SstMeta>,
    pub name: ::std::string::String,
    pub rewrite_rule: ::protobuf::SingularPtrField<RewriteRule>,
    pub storage_backend: ::protobuf::SingularPtrField<super::brpb::StorageBackend>,
    pub storage_cache_id: ::std::string::String,
    pub is_raw_kv: bool,
    pub cipher_info: ::protobuf::SingularPtrField<super::brpb::CipherInfo>,
    pub request_type: DownloadRequestType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownloadRequest {
    fn default() -> &'a DownloadRequest {
        <DownloadRequest as ::protobuf::Message>::default_instance()
    }
}

impl DownloadRequest {
    pub fn new() -> DownloadRequest {
        ::std::default::Default::default()
    }

    // .import_sstpb.SSTMeta sst = 2;


    pub fn get_sst(&self) -> &SstMeta {
        self.sst.as_ref().unwrap_or_else(|| SstMeta::default_instance())
    }
    pub fn clear_sst(&mut self) {
        self.sst.clear();
    }

    pub fn has_sst(&self) -> bool {
        self.sst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sst(&mut self, v: SstMeta) {
        self.sst = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sst(&mut self) -> &mut SstMeta {
        if self.sst.is_none() {
            self.sst.set_default();
        }
        self.sst.as_mut().unwrap()
    }

    // Take field
    pub fn take_sst(&mut self) -> SstMeta {
        self.sst.take().unwrap_or_else(|| SstMeta::new())
    }

    // string name = 9;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .import_sstpb.RewriteRule rewrite_rule = 13;


    pub fn get_rewrite_rule(&self) -> &RewriteRule {
        self.rewrite_rule.as_ref().unwrap_or_else(|| RewriteRule::default_instance())
    }
    pub fn clear_rewrite_rule(&mut self) {
        self.rewrite_rule.clear();
    }

    pub fn has_rewrite_rule(&self) -> bool {
        self.rewrite_rule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rewrite_rule(&mut self, v: RewriteRule) {
        self.rewrite_rule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rewrite_rule(&mut self) -> &mut RewriteRule {
        if self.rewrite_rule.is_none() {
            self.rewrite_rule.set_default();
        }
        self.rewrite_rule.as_mut().unwrap()
    }

    // Take field
    pub fn take_rewrite_rule(&mut self) -> RewriteRule {
        self.rewrite_rule.take().unwrap_or_else(|| RewriteRule::new())
    }

    // .backup.StorageBackend storage_backend = 14;


    pub fn get_storage_backend(&self) -> &super::brpb::StorageBackend {
        self.storage_backend.as_ref().unwrap_or_else(|| super::brpb::StorageBackend::default_instance())
    }
    pub fn clear_storage_backend(&mut self) {
        self.storage_backend.clear();
    }

    pub fn has_storage_backend(&self) -> bool {
        self.storage_backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage_backend(&mut self, v: super::brpb::StorageBackend) {
        self.storage_backend = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage_backend(&mut self) -> &mut super::brpb::StorageBackend {
        if self.storage_backend.is_none() {
            self.storage_backend.set_default();
        }
        self.storage_backend.as_mut().unwrap()
    }

    // Take field
    pub fn take_storage_backend(&mut self) -> super::brpb::StorageBackend {
        self.storage_backend.take().unwrap_or_else(|| super::brpb::StorageBackend::new())
    }

    // string storage_cache_id = 17;


    pub fn get_storage_cache_id(&self) -> &str {
        &self.storage_cache_id
    }
    pub fn clear_storage_cache_id(&mut self) {
        self.storage_cache_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage_cache_id(&mut self, v: ::std::string::String) {
        self.storage_cache_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage_cache_id(&mut self) -> &mut ::std::string::String {
        &mut self.storage_cache_id
    }

    // Take field
    pub fn take_storage_cache_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.storage_cache_id, ::std::string::String::new())
    }

    // bool is_raw_kv = 15;


    pub fn get_is_raw_kv(&self) -> bool {
        self.is_raw_kv
    }
    pub fn clear_is_raw_kv(&mut self) {
        self.is_raw_kv = false;
    }

    // Param is passed by value, moved
    pub fn set_is_raw_kv(&mut self, v: bool) {
        self.is_raw_kv = v;
    }

    // .backup.CipherInfo cipher_info = 16;


    pub fn get_cipher_info(&self) -> &super::brpb::CipherInfo {
        self.cipher_info.as_ref().unwrap_or_else(|| super::brpb::CipherInfo::default_instance())
    }
    pub fn clear_cipher_info(&mut self) {
        self.cipher_info.clear();
    }

    pub fn has_cipher_info(&self) -> bool {
        self.cipher_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cipher_info(&mut self, v: super::brpb::CipherInfo) {
        self.cipher_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cipher_info(&mut self) -> &mut super::brpb::CipherInfo {
        if self.cipher_info.is_none() {
            self.cipher_info.set_default();
        }
        self.cipher_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_cipher_info(&mut self) -> super::brpb::CipherInfo {
        self.cipher_info.take().unwrap_or_else(|| super::brpb::CipherInfo::new())
    }

    // .import_sstpb.DownloadRequestType request_type = 18;


    pub fn get_request_type(&self) -> DownloadRequestType {
        self.request_type
    }
    pub fn clear_request_type(&mut self) {
        self.request_type = DownloadRequestType::Legacy;
    }

    // Param is passed by value, moved
    pub fn set_request_type(&mut self, v: DownloadRequestType) {
        self.request_type = v;
    }
}

impl ::protobuf::Message for DownloadRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.sst {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rewrite_rule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storage_backend {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cipher_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sst)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rewrite_rule)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storage_backend)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.storage_cache_id)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_raw_kv = tmp;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cipher_info)?;
                },
                18 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.request_type = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sst.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.name);
        }
        if let Some(ref v) = self.rewrite_rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.storage_backend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.storage_cache_id.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.storage_cache_id);
        }
        if self.is_raw_kv != false {
            my_size += 2;
        }
        if let Some(ref v) = self.cipher_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.request_type != DownloadRequestType::Legacy {
            my_size += ::protobuf::rt::enum_size(18, self.request_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sst.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(9, &self.name)?;
        }
        if let Some(ref v) = self.rewrite_rule.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.storage_backend.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.storage_cache_id.is_empty() {
            os.write_string(17, &self.storage_cache_id)?;
        }
        if self.is_raw_kv != false {
            os.write_bool(15, self.is_raw_kv)?;
        }
        if let Some(ref v) = self.cipher_info.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.request_type != DownloadRequestType::Legacy {
            os.write_enum(18, self.request_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownloadRequest {
        DownloadRequest::new()
    }

    fn default_instance() -> &'static DownloadRequest {
        static mut instance: ::protobuf::lazy::Lazy<DownloadRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DownloadRequest,
        };
        unsafe {
            instance.get(DownloadRequest::new)
        }
    }
}

impl ::protobuf::Clear for DownloadRequest {
    fn clear(&mut self) {
        self.sst.clear();
        self.name.clear();
        self.rewrite_rule.clear();
        self.storage_backend.clear();
        self.storage_cache_id.clear();
        self.is_raw_kv = false;
        self.cipher_info.clear();
        self.request_type = DownloadRequestType::Legacy;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for DownloadRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.sst, "sst", buf);
        ::protobuf::PbPrint::fmt(&self.name, "name", buf);
        ::protobuf::PbPrint::fmt(&self.rewrite_rule, "rewrite_rule", buf);
        ::protobuf::PbPrint::fmt(&self.storage_backend, "storage_backend", buf);
        ::protobuf::PbPrint::fmt(&self.storage_cache_id, "storage_cache_id", buf);
        ::protobuf::PbPrint::fmt(&self.is_raw_kv, "is_raw_kv", buf);
        ::protobuf::PbPrint::fmt(&self.cipher_info, "cipher_info", buf);
        ::protobuf::PbPrint::fmt(&self.request_type, "request_type", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for DownloadRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.sst, "sst", &mut s);
        ::protobuf::PbPrint::fmt(&self.name, "name", &mut s);
        ::protobuf::PbPrint::fmt(&self.rewrite_rule, "rewrite_rule", &mut s);
        ::protobuf::PbPrint::fmt(&self.storage_backend, "storage_backend", &mut s);
        ::protobuf::PbPrint::fmt(&self.storage_cache_id, "storage_cache_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.is_raw_kv, "is_raw_kv", &mut s);
        ::protobuf::PbPrint::fmt(&self.cipher_info, "cipher_info", &mut s);
        ::protobuf::PbPrint::fmt(&self.request_type, "request_type", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownloadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Error {
    // message fields
    pub message: ::std::string::String,
    pub store_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Error {
    fn default() -> &'a Error {
        <Error as ::protobuf::Message>::default_instance()
    }
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // .errorpb.Error store_error = 2;


    pub fn get_store_error(&self) -> &super::errorpb::Error {
        self.store_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_store_error(&mut self) {
        self.store_error.clear();
    }

    pub fn has_store_error(&self) -> bool {
        self.store_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_error(&mut self, v: super::errorpb::Error) {
        self.store_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_error(&mut self) -> &mut super::errorpb::Error {
        if self.store_error.is_none() {
            self.store_error.set_default();
        }
        self.store_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_store_error(&mut self) -> super::errorpb::Error {
        self.store_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }
}

impl ::protobuf::Message for Error {
    fn is_initialized(&self) -> bool {
        for v in &self.store_error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.store_error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        if let Some(ref v) = self.store_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        if let Some(ref v) = self.store_error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Error {
        Error::new()
    }

    fn default_instance() -> &'static Error {
        static mut instance: ::protobuf::lazy::Lazy<Error> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Error,
        };
        unsafe {
            instance.get(Error::new)
        }
    }
}

impl ::protobuf::Clear for Error {
    fn clear(&mut self) {
        self.message.clear();
        self.store_error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Error {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.message, "message", buf);
        ::protobuf::PbPrint::fmt(&self.store_error, "store_error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Error {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.message, "message", &mut s);
        ::protobuf::PbPrint::fmt(&self.store_error, "store_error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownloadResponse {
    // message fields
    pub range: ::protobuf::SingularPtrField<Range>,
    pub is_empty: bool,
    pub error: ::protobuf::SingularPtrField<Error>,
    pub crc32: u32,
    pub length: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownloadResponse {
    fn default() -> &'a DownloadResponse {
        <DownloadResponse as ::protobuf::Message>::default_instance()
    }
}

impl DownloadResponse {
    pub fn new() -> DownloadResponse {
        ::std::default::Default::default()
    }

    // .import_sstpb.Range range = 1;


    pub fn get_range(&self) -> &Range {
        self.range.as_ref().unwrap_or_else(|| Range::default_instance())
    }
    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: Range) {
        self.range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&mut self) -> &mut Range {
        if self.range.is_none() {
            self.range.set_default();
        }
        self.range.as_mut().unwrap()
    }

    // Take field
    pub fn take_range(&mut self) -> Range {
        self.range.take().unwrap_or_else(|| Range::new())
    }

    // bool is_empty = 2;


    pub fn get_is_empty(&self) -> bool {
        self.is_empty
    }
    pub fn clear_is_empty(&mut self) {
        self.is_empty = false;
    }

    // Param is passed by value, moved
    pub fn set_is_empty(&mut self, v: bool) {
        self.is_empty = v;
    }

    // .import_sstpb.Error error = 3;


    pub fn get_error(&self) -> &Error {
        self.error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        self.error.take().unwrap_or_else(|| Error::new())
    }

    // uint32 crc32 = 4;


    pub fn get_crc32(&self) -> u32 {
        self.crc32
    }
    pub fn clear_crc32(&mut self) {
        self.crc32 = 0;
    }

    // Param is passed by value, moved
    pub fn set_crc32(&mut self, v: u32) {
        self.crc32 = v;
    }

    // uint64 length = 5;


    pub fn get_length(&self) -> u64 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = v;
    }
}

impl ::protobuf::Message for DownloadResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.range {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.range)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_empty = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.crc32 = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_empty != false {
            my_size += 2;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.crc32 != 0 {
            my_size += ::protobuf::rt::value_size(4, self.crc32, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(5, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.range.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_empty != false {
            os.write_bool(2, self.is_empty)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.crc32 != 0 {
            os.write_uint32(4, self.crc32)?;
        }
        if self.length != 0 {
            os.write_uint64(5, self.length)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownloadResponse {
        DownloadResponse::new()
    }

    fn default_instance() -> &'static DownloadResponse {
        static mut instance: ::protobuf::lazy::Lazy<DownloadResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DownloadResponse,
        };
        unsafe {
            instance.get(DownloadResponse::new)
        }
    }
}

impl ::protobuf::Clear for DownloadResponse {
    fn clear(&mut self) {
        self.range.clear();
        self.is_empty = false;
        self.error.clear();
        self.crc32 = 0;
        self.length = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for DownloadResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.range, "range", buf);
        ::protobuf::PbPrint::fmt(&self.is_empty, "is_empty", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.crc32, "crc32", buf);
        ::protobuf::PbPrint::fmt(&self.length, "length", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for DownloadResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.range, "range", &mut s);
        ::protobuf::PbPrint::fmt(&self.is_empty, "is_empty", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.crc32, "crc32", &mut s);
        ::protobuf::PbPrint::fmt(&self.length, "length", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownloadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetDownloadSpeedLimitRequest {
    // message fields
    pub speed_limit: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetDownloadSpeedLimitRequest {
    fn default() -> &'a SetDownloadSpeedLimitRequest {
        <SetDownloadSpeedLimitRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetDownloadSpeedLimitRequest {
    pub fn new() -> SetDownloadSpeedLimitRequest {
        ::std::default::Default::default()
    }

    // uint64 speed_limit = 1;


    pub fn get_speed_limit(&self) -> u64 {
        self.speed_limit
    }
    pub fn clear_speed_limit(&mut self) {
        self.speed_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_speed_limit(&mut self, v: u64) {
        self.speed_limit = v;
    }
}

impl ::protobuf::Message for SetDownloadSpeedLimitRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.speed_limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.speed_limit != 0 {
            my_size += ::protobuf::rt::value_size(1, self.speed_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.speed_limit != 0 {
            os.write_uint64(1, self.speed_limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetDownloadSpeedLimitRequest {
        SetDownloadSpeedLimitRequest::new()
    }

    fn default_instance() -> &'static SetDownloadSpeedLimitRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetDownloadSpeedLimitRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetDownloadSpeedLimitRequest,
        };
        unsafe {
            instance.get(SetDownloadSpeedLimitRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetDownloadSpeedLimitRequest {
    fn clear(&mut self) {
        self.speed_limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for SetDownloadSpeedLimitRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.speed_limit, "speed_limit", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for SetDownloadSpeedLimitRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.speed_limit, "speed_limit", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetDownloadSpeedLimitRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetDownloadSpeedLimitResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetDownloadSpeedLimitResponse {
    fn default() -> &'a SetDownloadSpeedLimitResponse {
        <SetDownloadSpeedLimitResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetDownloadSpeedLimitResponse {
    pub fn new() -> SetDownloadSpeedLimitResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetDownloadSpeedLimitResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetDownloadSpeedLimitResponse {
        SetDownloadSpeedLimitResponse::new()
    }

    fn default_instance() -> &'static SetDownloadSpeedLimitResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetDownloadSpeedLimitResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetDownloadSpeedLimitResponse,
        };
        unsafe {
            instance.get(SetDownloadSpeedLimitResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetDownloadSpeedLimitResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for SetDownloadSpeedLimitResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
    }
}
impl ::std::fmt::Debug for SetDownloadSpeedLimitResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        Ok(())
    }
}

impl ::protobuf::reflect::ProtobufValue for SetDownloadSpeedLimitResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pair {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub op: PairOp,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pair {
    fn default() -> &'a Pair {
        <Pair as ::protobuf::Message>::default_instance()
    }
}

impl Pair {
    pub fn new() -> Pair {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // .import_sstpb.Pair.OP op = 3;


    pub fn get_op(&self) -> PairOp {
        self.op
    }
    pub fn clear_op(&mut self) {
        self.op = PairOp::Put;
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: PairOp) {
        self.op = v;
    }
}

impl ::protobuf::Message for Pair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.op = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if self.op != PairOp::Put {
            my_size += ::protobuf::rt::enum_size(3, self.op);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if self.op != PairOp::Put {
            os.write_enum(3, self.op.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pair {
        Pair::new()
    }

    fn default_instance() -> &'static Pair {
        static mut instance: ::protobuf::lazy::Lazy<Pair> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Pair,
        };
        unsafe {
            instance.get(Pair::new)
        }
    }
}

impl ::protobuf::Clear for Pair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.op = PairOp::Put;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for Pair {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.value, "value", buf);
        ::protobuf::PbPrint::fmt(&self.op, "op", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for Pair {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.value, "value", &mut s);
        ::protobuf::PbPrint::fmt(&self.op, "op", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pair {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PairOp {
    Put = 0,
    Delete = 1,
}

impl ::protobuf::ProtobufEnum for PairOp {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PairOp> {
        match value {
            0 => ::std::option::Option::Some(PairOp::Put),
            1 => ::std::option::Option::Some(PairOp::Delete),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PairOp] = &[
            PairOp::Put,
            PairOp::Delete,
        ];
        values
    }
}

impl ::std::marker::Copy for PairOp {
}

impl ::protobuf::PbPrint for PairOp {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == PairOp::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for PairOp {
    fn default() -> Self {
        PairOp::Put
    }
}

impl ::protobuf::reflect::ProtobufValue for PairOp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteBatch {
    // message fields
    pub commit_ts: u64,
    pub pairs: ::protobuf::RepeatedField<Pair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteBatch {
    fn default() -> &'a WriteBatch {
        <WriteBatch as ::protobuf::Message>::default_instance()
    }
}

impl WriteBatch {
    pub fn new() -> WriteBatch {
        ::std::default::Default::default()
    }

    // uint64 commit_ts = 1;


    pub fn get_commit_ts(&self) -> u64 {
        self.commit_ts
    }
    pub fn clear_commit_ts(&mut self) {
        self.commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_ts(&mut self, v: u64) {
        self.commit_ts = v;
    }

    // repeated .import_sstpb.Pair pairs = 2;


    pub fn get_pairs(&self) -> &[Pair] {
        &self.pairs
    }
    pub fn clear_pairs(&mut self) {
        self.pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pairs(&mut self, v: ::protobuf::RepeatedField<Pair>) {
        self.pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pairs(&mut self) -> &mut ::protobuf::RepeatedField<Pair> {
        &mut self.pairs
    }

    // Take field
    pub fn take_pairs(&mut self) -> ::protobuf::RepeatedField<Pair> {
        ::std::mem::replace(&mut self.pairs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WriteBatch {
    fn is_initialized(&self) -> bool {
        for v in &self.pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_ts = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pairs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(1, self.commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.commit_ts != 0 {
            os.write_uint64(1, self.commit_ts)?;
        }
        for v in &self.pairs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteBatch {
        WriteBatch::new()
    }

    fn default_instance() -> &'static WriteBatch {
        static mut instance: ::protobuf::lazy::Lazy<WriteBatch> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteBatch,
        };
        unsafe {
            instance.get(WriteBatch::new)
        }
    }
}

impl ::protobuf::Clear for WriteBatch {
    fn clear(&mut self) {
        self.commit_ts = 0;
        self.pairs.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for WriteBatch {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", buf);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for WriteBatch {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteBatch {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteRequest {
    // message oneof groups
    pub chunk: ::std::option::Option<WriteRequest_oneof_chunk>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteRequest {
    fn default() -> &'a WriteRequest {
        <WriteRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq)]
pub enum WriteRequest_oneof_chunk {
    Meta(SstMeta),
    Batch(WriteBatch),
}

impl ::protobuf::PbPrint for WriteRequest_oneof_chunk {
    fn fmt(&self, name: &str, buf: &mut String) {
        match self {
            WriteRequest_oneof_chunk::Meta(v) => ::protobuf::PbPrint::fmt(v, name, buf),
            WriteRequest_oneof_chunk::Batch(v) => ::protobuf::PbPrint::fmt(v, name, buf),
        }
    }
}

impl WriteRequest {
    pub fn new() -> WriteRequest {
        ::std::default::Default::default()
    }

    // .import_sstpb.SSTMeta meta = 1;


    pub fn get_meta(&self) -> &SstMeta {
        match self.chunk {
            ::std::option::Option::Some(WriteRequest_oneof_chunk::Meta(ref v)) => v,
            _ => SstMeta::default_instance(),
        }
    }
    pub fn clear_meta(&mut self) {
        self.chunk = ::std::option::Option::None;
    }

    pub fn has_meta(&self) -> bool {
        match self.chunk {
            ::std::option::Option::Some(WriteRequest_oneof_chunk::Meta(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_meta(&mut self, v: SstMeta) {
        self.chunk = ::std::option::Option::Some(WriteRequest_oneof_chunk::Meta(v))
    }

    // Mutable pointer to the field.
    pub fn mut_meta(&mut self) -> &mut SstMeta {
        if let ::std::option::Option::Some(WriteRequest_oneof_chunk::Meta(_)) = self.chunk {
        } else {
            self.chunk = ::std::option::Option::Some(WriteRequest_oneof_chunk::Meta(SstMeta::new()));
        }
        match self.chunk {
            ::std::option::Option::Some(WriteRequest_oneof_chunk::Meta(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_meta(&mut self) -> SstMeta {
        if self.has_meta() {
            match self.chunk.take() {
                ::std::option::Option::Some(WriteRequest_oneof_chunk::Meta(v)) => v,
                _ => panic!(),
            }
        } else {
            SstMeta::new()
        }
    }

    // .import_sstpb.WriteBatch batch = 2;


    pub fn get_batch(&self) -> &WriteBatch {
        match self.chunk {
            ::std::option::Option::Some(WriteRequest_oneof_chunk::Batch(ref v)) => v,
            _ => WriteBatch::default_instance(),
        }
    }
    pub fn clear_batch(&mut self) {
        self.chunk = ::std::option::Option::None;
    }

    pub fn has_batch(&self) -> bool {
        match self.chunk {
            ::std::option::Option::Some(WriteRequest_oneof_chunk::Batch(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_batch(&mut self, v: WriteBatch) {
        self.chunk = ::std::option::Option::Some(WriteRequest_oneof_chunk::Batch(v))
    }

    // Mutable pointer to the field.
    pub fn mut_batch(&mut self) -> &mut WriteBatch {
        if let ::std::option::Option::Some(WriteRequest_oneof_chunk::Batch(_)) = self.chunk {
        } else {
            self.chunk = ::std::option::Option::Some(WriteRequest_oneof_chunk::Batch(WriteBatch::new()));
        }
        match self.chunk {
            ::std::option::Option::Some(WriteRequest_oneof_chunk::Batch(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_batch(&mut self) -> WriteBatch {
        if self.has_batch() {
            match self.chunk.take() {
                ::std::option::Option::Some(WriteRequest_oneof_chunk::Batch(v)) => v,
                _ => panic!(),
            }
        } else {
            WriteBatch::new()
        }
    }
}

impl ::protobuf::Message for WriteRequest {
    fn is_initialized(&self) -> bool {
        if let Some(WriteRequest_oneof_chunk::Meta(ref v)) = self.chunk {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(WriteRequest_oneof_chunk::Batch(ref v)) = self.chunk {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chunk = ::std::option::Option::Some(WriteRequest_oneof_chunk::Meta(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chunk = ::std::option::Option::Some(WriteRequest_oneof_chunk::Batch(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.chunk {
            match v {
                &WriteRequest_oneof_chunk::Meta(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &WriteRequest_oneof_chunk::Batch(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.chunk {
            match v {
                &WriteRequest_oneof_chunk::Meta(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &WriteRequest_oneof_chunk::Batch(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteRequest {
        WriteRequest::new()
    }

    fn default_instance() -> &'static WriteRequest {
        static mut instance: ::protobuf::lazy::Lazy<WriteRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteRequest,
        };
        unsafe {
            instance.get(WriteRequest::new)
        }
    }
}

impl ::protobuf::Clear for WriteRequest {
    fn clear(&mut self) {
        self.chunk = ::std::option::Option::None;
        self.chunk = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for WriteRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.chunk, "chunk", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for WriteRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.chunk, "chunk", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<Error>,
    pub metas: ::protobuf::RepeatedField<SstMeta>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WriteResponse {
    fn default() -> &'a WriteResponse {
        <WriteResponse as ::protobuf::Message>::default_instance()
    }
}

impl WriteResponse {
    pub fn new() -> WriteResponse {
        ::std::default::Default::default()
    }

    // .import_sstpb.Error error = 1;


    pub fn get_error(&self) -> &Error {
        self.error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        self.error.take().unwrap_or_else(|| Error::new())
    }

    // repeated .import_sstpb.SSTMeta metas = 2;


    pub fn get_metas(&self) -> &[SstMeta] {
        &self.metas
    }
    pub fn clear_metas(&mut self) {
        self.metas.clear();
    }

    // Param is passed by value, moved
    pub fn set_metas(&mut self, v: ::protobuf::RepeatedField<SstMeta>) {
        self.metas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metas(&mut self) -> &mut ::protobuf::RepeatedField<SstMeta> {
        &mut self.metas
    }

    // Take field
    pub fn take_metas(&mut self) -> ::protobuf::RepeatedField<SstMeta> {
        ::std::mem::replace(&mut self.metas, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for WriteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.metas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.metas {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteResponse {
        WriteResponse::new()
    }

    fn default_instance() -> &'static WriteResponse {
        static mut instance: ::protobuf::lazy::Lazy<WriteResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteResponse,
        };
        unsafe {
            instance.get(WriteResponse::new)
        }
    }
}

impl ::protobuf::Clear for WriteResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.metas.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for WriteResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.metas, "metas", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for WriteResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.metas, "metas", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawWriteBatch {
    // message fields
    pub ttl: u64,
    pub pairs: ::protobuf::RepeatedField<Pair>,
    pub ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawWriteBatch {
    fn default() -> &'a RawWriteBatch {
        <RawWriteBatch as ::protobuf::Message>::default_instance()
    }
}

impl RawWriteBatch {
    pub fn new() -> RawWriteBatch {
        ::std::default::Default::default()
    }

    // uint64 ttl = 1;


    pub fn get_ttl(&self) -> u64 {
        self.ttl
    }
    pub fn clear_ttl(&mut self) {
        self.ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: u64) {
        self.ttl = v;
    }

    // repeated .import_sstpb.Pair pairs = 2;


    pub fn get_pairs(&self) -> &[Pair] {
        &self.pairs
    }
    pub fn clear_pairs(&mut self) {
        self.pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pairs(&mut self, v: ::protobuf::RepeatedField<Pair>) {
        self.pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pairs(&mut self) -> &mut ::protobuf::RepeatedField<Pair> {
        &mut self.pairs
    }

    // Take field
    pub fn take_pairs(&mut self) -> ::protobuf::RepeatedField<Pair> {
        ::std::mem::replace(&mut self.pairs, ::protobuf::RepeatedField::new())
    }

    // uint64 ts = 3;


    pub fn get_ts(&self) -> u64 {
        self.ts
    }
    pub fn clear_ts(&mut self) {
        self.ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_ts(&mut self, v: u64) {
        self.ts = v;
    }
}

impl ::protobuf::Message for RawWriteBatch {
    fn is_initialized(&self) -> bool {
        for v in &self.pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ttl = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pairs)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ttl != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.ts != 0 {
            my_size += ::protobuf::rt::value_size(3, self.ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.ttl != 0 {
            os.write_uint64(1, self.ttl)?;
        }
        for v in &self.pairs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.ts != 0 {
            os.write_uint64(3, self.ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawWriteBatch {
        RawWriteBatch::new()
    }

    fn default_instance() -> &'static RawWriteBatch {
        static mut instance: ::protobuf::lazy::Lazy<RawWriteBatch> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawWriteBatch,
        };
        unsafe {
            instance.get(RawWriteBatch::new)
        }
    }
}

impl ::protobuf::Clear for RawWriteBatch {
    fn clear(&mut self) {
        self.ttl = 0;
        self.pairs.clear();
        self.ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawWriteBatch {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.ttl, "ttl", buf);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", buf);
        ::protobuf::PbPrint::fmt(&self.ts, "ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawWriteBatch {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.ttl, "ttl", &mut s);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", &mut s);
        ::protobuf::PbPrint::fmt(&self.ts, "ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawWriteBatch {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawWriteRequest {
    // message oneof groups
    pub chunk: ::std::option::Option<RawWriteRequest_oneof_chunk>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawWriteRequest {
    fn default() -> &'a RawWriteRequest {
        <RawWriteRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq)]
pub enum RawWriteRequest_oneof_chunk {
    Meta(SstMeta),
    Batch(RawWriteBatch),
}

impl ::protobuf::PbPrint for RawWriteRequest_oneof_chunk {
    fn fmt(&self, name: &str, buf: &mut String) {
        match self {
            RawWriteRequest_oneof_chunk::Meta(v) => ::protobuf::PbPrint::fmt(v, name, buf),
            RawWriteRequest_oneof_chunk::Batch(v) => ::protobuf::PbPrint::fmt(v, name, buf),
        }
    }
}

impl RawWriteRequest {
    pub fn new() -> RawWriteRequest {
        ::std::default::Default::default()
    }

    // .import_sstpb.SSTMeta meta = 1;


    pub fn get_meta(&self) -> &SstMeta {
        match self.chunk {
            ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Meta(ref v)) => v,
            _ => SstMeta::default_instance(),
        }
    }
    pub fn clear_meta(&mut self) {
        self.chunk = ::std::option::Option::None;
    }

    pub fn has_meta(&self) -> bool {
        match self.chunk {
            ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Meta(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_meta(&mut self, v: SstMeta) {
        self.chunk = ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Meta(v))
    }

    // Mutable pointer to the field.
    pub fn mut_meta(&mut self) -> &mut SstMeta {
        if let ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Meta(_)) = self.chunk {
        } else {
            self.chunk = ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Meta(SstMeta::new()));
        }
        match self.chunk {
            ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Meta(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_meta(&mut self) -> SstMeta {
        if self.has_meta() {
            match self.chunk.take() {
                ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Meta(v)) => v,
                _ => panic!(),
            }
        } else {
            SstMeta::new()
        }
    }

    // .import_sstpb.RawWriteBatch batch = 2;


    pub fn get_batch(&self) -> &RawWriteBatch {
        match self.chunk {
            ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Batch(ref v)) => v,
            _ => RawWriteBatch::default_instance(),
        }
    }
    pub fn clear_batch(&mut self) {
        self.chunk = ::std::option::Option::None;
    }

    pub fn has_batch(&self) -> bool {
        match self.chunk {
            ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Batch(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_batch(&mut self, v: RawWriteBatch) {
        self.chunk = ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Batch(v))
    }

    // Mutable pointer to the field.
    pub fn mut_batch(&mut self) -> &mut RawWriteBatch {
        if let ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Batch(_)) = self.chunk {
        } else {
            self.chunk = ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Batch(RawWriteBatch::new()));
        }
        match self.chunk {
            ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Batch(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_batch(&mut self) -> RawWriteBatch {
        if self.has_batch() {
            match self.chunk.take() {
                ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Batch(v)) => v,
                _ => panic!(),
            }
        } else {
            RawWriteBatch::new()
        }
    }
}

impl ::protobuf::Message for RawWriteRequest {
    fn is_initialized(&self) -> bool {
        if let Some(RawWriteRequest_oneof_chunk::Meta(ref v)) = self.chunk {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RawWriteRequest_oneof_chunk::Batch(ref v)) = self.chunk {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chunk = ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Meta(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.chunk = ::std::option::Option::Some(RawWriteRequest_oneof_chunk::Batch(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.chunk {
            match v {
                &RawWriteRequest_oneof_chunk::Meta(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RawWriteRequest_oneof_chunk::Batch(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.chunk {
            match v {
                &RawWriteRequest_oneof_chunk::Meta(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RawWriteRequest_oneof_chunk::Batch(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawWriteRequest {
        RawWriteRequest::new()
    }

    fn default_instance() -> &'static RawWriteRequest {
        static mut instance: ::protobuf::lazy::Lazy<RawWriteRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawWriteRequest,
        };
        unsafe {
            instance.get(RawWriteRequest::new)
        }
    }
}

impl ::protobuf::Clear for RawWriteRequest {
    fn clear(&mut self) {
        self.chunk = ::std::option::Option::None;
        self.chunk = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawWriteRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.chunk, "chunk", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawWriteRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.chunk, "chunk", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawWriteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawWriteResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<Error>,
    pub metas: ::protobuf::RepeatedField<SstMeta>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawWriteResponse {
    fn default() -> &'a RawWriteResponse {
        <RawWriteResponse as ::protobuf::Message>::default_instance()
    }
}

impl RawWriteResponse {
    pub fn new() -> RawWriteResponse {
        ::std::default::Default::default()
    }

    // .import_sstpb.Error error = 1;


    pub fn get_error(&self) -> &Error {
        self.error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        self.error.take().unwrap_or_else(|| Error::new())
    }

    // repeated .import_sstpb.SSTMeta metas = 2;


    pub fn get_metas(&self) -> &[SstMeta] {
        &self.metas
    }
    pub fn clear_metas(&mut self) {
        self.metas.clear();
    }

    // Param is passed by value, moved
    pub fn set_metas(&mut self, v: ::protobuf::RepeatedField<SstMeta>) {
        self.metas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metas(&mut self) -> &mut ::protobuf::RepeatedField<SstMeta> {
        &mut self.metas
    }

    // Take field
    pub fn take_metas(&mut self) -> ::protobuf::RepeatedField<SstMeta> {
        ::std::mem::replace(&mut self.metas, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RawWriteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.metas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.metas {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawWriteResponse {
        RawWriteResponse::new()
    }

    fn default_instance() -> &'static RawWriteResponse {
        static mut instance: ::protobuf::lazy::Lazy<RawWriteResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawWriteResponse,
        };
        unsafe {
            instance.get(RawWriteResponse::new)
        }
    }
}

impl ::protobuf::Clear for RawWriteResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.metas.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for RawWriteResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        ::protobuf::PbPrint::fmt(&self.metas, "metas", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for RawWriteResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        ::protobuf::PbPrint::fmt(&self.metas, "metas", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawWriteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DuplicateDetectRequest {
    // message fields
    pub context: ::protobuf::SingularPtrField<super::kvrpcpb::Context>,
    pub start_key: ::std::vec::Vec<u8>,
    pub end_key: ::std::vec::Vec<u8>,
    pub key_only: bool,
    pub min_commit_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DuplicateDetectRequest {
    fn default() -> &'a DuplicateDetectRequest {
        <DuplicateDetectRequest as ::protobuf::Message>::default_instance()
    }
}

impl DuplicateDetectRequest {
    pub fn new() -> DuplicateDetectRequest {
        ::std::default::Default::default()
    }

    // .kvrpcpb.Context context = 1;


    pub fn get_context(&self) -> &super::kvrpcpb::Context {
        self.context.as_ref().unwrap_or_else(|| super::kvrpcpb::Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: super::kvrpcpb::Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut super::kvrpcpb::Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> super::kvrpcpb::Context {
        self.context.take().unwrap_or_else(|| super::kvrpcpb::Context::new())
    }

    // bytes start_key = 2;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // bytes end_key = 3;


    pub fn get_end_key(&self) -> &[u8] {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end_key, ::std::vec::Vec::new())
    }

    // bool key_only = 4;


    pub fn get_key_only(&self) -> bool {
        self.key_only
    }
    pub fn clear_key_only(&mut self) {
        self.key_only = false;
    }

    // Param is passed by value, moved
    pub fn set_key_only(&mut self, v: bool) {
        self.key_only = v;
    }

    // uint64 min_commit_ts = 5;


    pub fn get_min_commit_ts(&self) -> u64 {
        self.min_commit_ts
    }
    pub fn clear_min_commit_ts(&mut self) {
        self.min_commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_commit_ts(&mut self, v: u64) {
        self.min_commit_ts = v;
    }
}

impl ::protobuf::Message for DuplicateDetectRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end_key)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.key_only = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.min_commit_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.start_key);
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.end_key);
        }
        if self.key_only != false {
            my_size += 2;
        }
        if self.min_commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(5, self.min_commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.start_key.is_empty() {
            os.write_bytes(2, &self.start_key)?;
        }
        if !self.end_key.is_empty() {
            os.write_bytes(3, &self.end_key)?;
        }
        if self.key_only != false {
            os.write_bool(4, self.key_only)?;
        }
        if self.min_commit_ts != 0 {
            os.write_uint64(5, self.min_commit_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DuplicateDetectRequest {
        DuplicateDetectRequest::new()
    }

    fn default_instance() -> &'static DuplicateDetectRequest {
        static mut instance: ::protobuf::lazy::Lazy<DuplicateDetectRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DuplicateDetectRequest,
        };
        unsafe {
            instance.get(DuplicateDetectRequest::new)
        }
    }
}

impl ::protobuf::Clear for DuplicateDetectRequest {
    fn clear(&mut self) {
        self.context.clear();
        self.start_key.clear();
        self.end_key.clear();
        self.key_only = false;
        self.min_commit_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for DuplicateDetectRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", buf);
        ::protobuf::PbPrint::fmt(&self.key_only, "key_only", buf);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for DuplicateDetectRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.key_only, "key_only", &mut s);
        ::protobuf::PbPrint::fmt(&self.min_commit_ts, "min_commit_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for DuplicateDetectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KvPair {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub commit_ts: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KvPair {
    fn default() -> &'a KvPair {
        <KvPair as ::protobuf::Message>::default_instance()
    }
}

impl KvPair {
    pub fn new() -> KvPair {
        ::std::default::Default::default()
    }

    // bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    // uint64 commit_ts = 3;


    pub fn get_commit_ts(&self) -> u64 {
        self.commit_ts
    }
    pub fn clear_commit_ts(&mut self) {
        self.commit_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_commit_ts(&mut self, v: u64) {
        self.commit_ts = v;
    }
}

impl ::protobuf::Message for KvPair {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.commit_ts = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        if self.commit_ts != 0 {
            my_size += ::protobuf::rt::value_size(3, self.commit_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        if self.commit_ts != 0 {
            os.write_uint64(3, self.commit_ts)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KvPair {
        KvPair::new()
    }

    fn default_instance() -> &'static KvPair {
        static mut instance: ::protobuf::lazy::Lazy<KvPair> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KvPair,
        };
        unsafe {
            instance.get(KvPair::new)
        }
    }
}

impl ::protobuf::Clear for KvPair {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.commit_ts = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for KvPair {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.key, "key", buf);
        ::protobuf::PbPrint::fmt(&self.value, "value", buf);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for KvPair {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.key, "key", &mut s);
        ::protobuf::PbPrint::fmt(&self.value, "value", &mut s);
        ::protobuf::PbPrint::fmt(&self.commit_ts, "commit_ts", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for KvPair {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DuplicateDetectResponse {
    // message fields
    pub region_error: ::protobuf::SingularPtrField<super::errorpb::Error>,
    pub key_error: ::protobuf::SingularPtrField<Error>,
    pub pairs: ::protobuf::RepeatedField<KvPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DuplicateDetectResponse {
    fn default() -> &'a DuplicateDetectResponse {
        <DuplicateDetectResponse as ::protobuf::Message>::default_instance()
    }
}

impl DuplicateDetectResponse {
    pub fn new() -> DuplicateDetectResponse {
        ::std::default::Default::default()
    }

    // .errorpb.Error region_error = 1;


    pub fn get_region_error(&self) -> &super::errorpb::Error {
        self.region_error.as_ref().unwrap_or_else(|| super::errorpb::Error::default_instance())
    }
    pub fn clear_region_error(&mut self) {
        self.region_error.clear();
    }

    pub fn has_region_error(&self) -> bool {
        self.region_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_error(&mut self, v: super::errorpb::Error) {
        self.region_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_region_error(&mut self) -> &mut super::errorpb::Error {
        if self.region_error.is_none() {
            self.region_error.set_default();
        }
        self.region_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_region_error(&mut self) -> super::errorpb::Error {
        self.region_error.take().unwrap_or_else(|| super::errorpb::Error::new())
    }

    // .import_sstpb.Error key_error = 2;


    pub fn get_key_error(&self) -> &Error {
        self.key_error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_key_error(&mut self) {
        self.key_error.clear();
    }

    pub fn has_key_error(&self) -> bool {
        self.key_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_error(&mut self, v: Error) {
        self.key_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_error(&mut self) -> &mut Error {
        if self.key_error.is_none() {
            self.key_error.set_default();
        }
        self.key_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_error(&mut self) -> Error {
        self.key_error.take().unwrap_or_else(|| Error::new())
    }

    // repeated .import_sstpb.KvPair pairs = 3;


    pub fn get_pairs(&self) -> &[KvPair] {
        &self.pairs
    }
    pub fn clear_pairs(&mut self) {
        self.pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_pairs(&mut self, v: ::protobuf::RepeatedField<KvPair>) {
        self.pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pairs(&mut self) -> &mut ::protobuf::RepeatedField<KvPair> {
        &mut self.pairs
    }

    // Take field
    pub fn take_pairs(&mut self) -> ::protobuf::RepeatedField<KvPair> {
        ::std::mem::replace(&mut self.pairs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DuplicateDetectResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.region_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.key_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.region_error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key_error)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pairs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.region_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.key_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.region_error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.key_error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.pairs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DuplicateDetectResponse {
        DuplicateDetectResponse::new()
    }

    fn default_instance() -> &'static DuplicateDetectResponse {
        static mut instance: ::protobuf::lazy::Lazy<DuplicateDetectResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DuplicateDetectResponse,
        };
        unsafe {
            instance.get(DuplicateDetectResponse::new)
        }
    }
}

impl ::protobuf::Clear for DuplicateDetectResponse {
    fn clear(&mut self) {
        self.region_error.clear();
        self.key_error.clear();
        self.pairs.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for DuplicateDetectResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", buf);
        ::protobuf::PbPrint::fmt(&self.key_error, "key_error", buf);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for DuplicateDetectResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.region_error, "region_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.key_error, "key_error", &mut s);
        ::protobuf::PbPrint::fmt(&self.pairs, "pairs", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for DuplicateDetectResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KvMeta {
    // message fields
    pub name: ::std::string::String,
    pub range_offset: u64,
    pub length: u64,
    pub range_length: u64,
    pub cf: ::std::string::String,
    pub is_delete: bool,
    pub start_ts: u64,
    pub restore_ts: u64,
    pub start_key: ::std::vec::Vec<u8>,
    pub end_key: ::std::vec::Vec<u8>,
    pub sha256: ::std::vec::Vec<u8>,
    pub start_snapshot_ts: u64,
    pub compression_type: super::brpb::CompressionType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KvMeta {
    fn default() -> &'a KvMeta {
        <KvMeta as ::protobuf::Message>::default_instance()
    }
}

impl KvMeta {
    pub fn new() -> KvMeta {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // uint64 range_offset = 11;


    pub fn get_range_offset(&self) -> u64 {
        self.range_offset
    }
    pub fn clear_range_offset(&mut self) {
        self.range_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_range_offset(&mut self, v: u64) {
        self.range_offset = v;
    }

    // uint64 length = 2;


    pub fn get_length(&self) -> u64 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = v;
    }

    // uint64 range_length = 12;


    pub fn get_range_length(&self) -> u64 {
        self.range_length
    }
    pub fn clear_range_length(&mut self) {
        self.range_length = 0;
    }

    // Param is passed by value, moved
    pub fn set_range_length(&mut self, v: u64) {
        self.range_length = v;
    }

    // string cf = 3;


    pub fn get_cf(&self) -> &str {
        &self.cf
    }
    pub fn clear_cf(&mut self) {
        self.cf.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf(&mut self, v: ::std::string::String) {
        self.cf = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf(&mut self) -> &mut ::std::string::String {
        &mut self.cf
    }

    // Take field
    pub fn take_cf(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf, ::std::string::String::new())
    }

    // bool is_delete = 4;


    pub fn get_is_delete(&self) -> bool {
        self.is_delete
    }
    pub fn clear_is_delete(&mut self) {
        self.is_delete = false;
    }

    // Param is passed by value, moved
    pub fn set_is_delete(&mut self, v: bool) {
        self.is_delete = v;
    }

    // uint64 start_ts = 10;


    pub fn get_start_ts(&self) -> u64 {
        self.start_ts
    }
    pub fn clear_start_ts(&mut self) {
        self.start_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_ts(&mut self, v: u64) {
        self.start_ts = v;
    }

    // uint64 restore_ts = 5;


    pub fn get_restore_ts(&self) -> u64 {
        self.restore_ts
    }
    pub fn clear_restore_ts(&mut self) {
        self.restore_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_restore_ts(&mut self, v: u64) {
        self.restore_ts = v;
    }

    // bytes start_key = 6;


    pub fn get_start_key(&self) -> &[u8] {
        &self.start_key
    }
    pub fn clear_start_key(&mut self) {
        self.start_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.start_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.start_key
    }

    // Take field
    pub fn take_start_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.start_key, ::std::vec::Vec::new())
    }

    // bytes end_key = 7;


    pub fn get_end_key(&self) -> &[u8] {
        &self.end_key
    }
    pub fn clear_end_key(&mut self) {
        self.end_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.end_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.end_key
    }

    // Take field
    pub fn take_end_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.end_key, ::std::vec::Vec::new())
    }

    // bytes sha256 = 8;


    pub fn get_sha256(&self) -> &[u8] {
        &self.sha256
    }
    pub fn clear_sha256(&mut self) {
        self.sha256.clear();
    }

    // Param is passed by value, moved
    pub fn set_sha256(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha256 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha256(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sha256
    }

    // Take field
    pub fn take_sha256(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sha256, ::std::vec::Vec::new())
    }

    // uint64 start_snapshot_ts = 9;


    pub fn get_start_snapshot_ts(&self) -> u64 {
        self.start_snapshot_ts
    }
    pub fn clear_start_snapshot_ts(&mut self) {
        self.start_snapshot_ts = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_snapshot_ts(&mut self, v: u64) {
        self.start_snapshot_ts = v;
    }

    // .backup.CompressionType compression_type = 13;


    pub fn get_compression_type(&self) -> super::brpb::CompressionType {
        self.compression_type
    }
    pub fn clear_compression_type(&mut self) {
        self.compression_type = super::brpb::CompressionType::Unknown;
    }

    // Param is passed by value, moved
    pub fn set_compression_type(&mut self, v: super::brpb::CompressionType) {
        self.compression_type = v;
    }
}

impl ::protobuf::Message for KvMeta {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.range_offset = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.range_length = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cf)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_delete = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_ts = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.restore_ts = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.start_key)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.end_key)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sha256)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_snapshot_ts = tmp;
                },
                13 => {
                    if wire_type == ::protobuf::wire_format::WireTypeVarint {self.compression_type = is.read_enum()?;} else {return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));}
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.range_offset != 0 {
            my_size += ::protobuf::rt::value_size(11, self.range_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(2, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.range_length != 0 {
            my_size += ::protobuf::rt::value_size(12, self.range_length, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.cf.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cf);
        }
        if self.is_delete != false {
            my_size += 2;
        }
        if self.start_ts != 0 {
            my_size += ::protobuf::rt::value_size(10, self.start_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.restore_ts != 0 {
            my_size += ::protobuf::rt::value_size(5, self.restore_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.start_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.start_key);
        }
        if !self.end_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.end_key);
        }
        if !self.sha256.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.sha256);
        }
        if self.start_snapshot_ts != 0 {
            my_size += ::protobuf::rt::value_size(9, self.start_snapshot_ts, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.compression_type != super::brpb::CompressionType::Unknown {
            my_size += ::protobuf::rt::enum_size(13, self.compression_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.range_offset != 0 {
            os.write_uint64(11, self.range_offset)?;
        }
        if self.length != 0 {
            os.write_uint64(2, self.length)?;
        }
        if self.range_length != 0 {
            os.write_uint64(12, self.range_length)?;
        }
        if !self.cf.is_empty() {
            os.write_string(3, &self.cf)?;
        }
        if self.is_delete != false {
            os.write_bool(4, self.is_delete)?;
        }
        if self.start_ts != 0 {
            os.write_uint64(10, self.start_ts)?;
        }
        if self.restore_ts != 0 {
            os.write_uint64(5, self.restore_ts)?;
        }
        if !self.start_key.is_empty() {
            os.write_bytes(6, &self.start_key)?;
        }
        if !self.end_key.is_empty() {
            os.write_bytes(7, &self.end_key)?;
        }
        if !self.sha256.is_empty() {
            os.write_bytes(8, &self.sha256)?;
        }
        if self.start_snapshot_ts != 0 {
            os.write_uint64(9, self.start_snapshot_ts)?;
        }
        if self.compression_type != super::brpb::CompressionType::Unknown {
            os.write_enum(13, self.compression_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KvMeta {
        KvMeta::new()
    }

    fn default_instance() -> &'static KvMeta {
        static mut instance: ::protobuf::lazy::Lazy<KvMeta> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KvMeta,
        };
        unsafe {
            instance.get(KvMeta::new)
        }
    }
}

impl ::protobuf::Clear for KvMeta {
    fn clear(&mut self) {
        self.name.clear();
        self.range_offset = 0;
        self.length = 0;
        self.range_length = 0;
        self.cf.clear();
        self.is_delete = false;
        self.start_ts = 0;
        self.restore_ts = 0;
        self.start_key.clear();
        self.end_key.clear();
        self.sha256.clear();
        self.start_snapshot_ts = 0;
        self.compression_type = super::brpb::CompressionType::Unknown;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for KvMeta {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.name, "name", buf);
        ::protobuf::PbPrint::fmt(&self.range_offset, "range_offset", buf);
        ::protobuf::PbPrint::fmt(&self.length, "length", buf);
        ::protobuf::PbPrint::fmt(&self.range_length, "range_length", buf);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", buf);
        ::protobuf::PbPrint::fmt(&self.is_delete, "is_delete", buf);
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", buf);
        ::protobuf::PbPrint::fmt(&self.restore_ts, "restore_ts", buf);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", buf);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", buf);
        ::protobuf::PbPrint::fmt(&self.sha256, "sha256", buf);
        ::protobuf::PbPrint::fmt(&self.start_snapshot_ts, "start_snapshot_ts", buf);
        ::protobuf::PbPrint::fmt(&self.compression_type, "compression_type", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for KvMeta {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.name, "name", &mut s);
        ::protobuf::PbPrint::fmt(&self.range_offset, "range_offset", &mut s);
        ::protobuf::PbPrint::fmt(&self.length, "length", &mut s);
        ::protobuf::PbPrint::fmt(&self.range_length, "range_length", &mut s);
        ::protobuf::PbPrint::fmt(&self.cf, "cf", &mut s);
        ::protobuf::PbPrint::fmt(&self.is_delete, "is_delete", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_ts, "start_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.restore_ts, "restore_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_key, "start_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.end_key, "end_key", &mut s);
        ::protobuf::PbPrint::fmt(&self.sha256, "sha256", &mut s);
        ::protobuf::PbPrint::fmt(&self.start_snapshot_ts, "start_snapshot_ts", &mut s);
        ::protobuf::PbPrint::fmt(&self.compression_type, "compression_type", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for KvMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplyRequest {
    // message fields
    pub meta: ::protobuf::SingularPtrField<KvMeta>,
    pub metas: ::protobuf::RepeatedField<KvMeta>,
    pub rewrite_rule: ::protobuf::SingularPtrField<RewriteRule>,
    pub rewrite_rules: ::protobuf::RepeatedField<RewriteRule>,
    pub storage_cache_id: ::std::string::String,
    pub storage_backend: ::protobuf::SingularPtrField<super::brpb::StorageBackend>,
    pub context: ::protobuf::SingularPtrField<super::kvrpcpb::Context>,
    pub cipher_info: ::protobuf::SingularPtrField<super::brpb::CipherInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplyRequest {
    fn default() -> &'a ApplyRequest {
        <ApplyRequest as ::protobuf::Message>::default_instance()
    }
}

impl ApplyRequest {
    pub fn new() -> ApplyRequest {
        ::std::default::Default::default()
    }

    // .import_sstpb.KVMeta meta = 1;


    pub fn get_meta(&self) -> &KvMeta {
        self.meta.as_ref().unwrap_or_else(|| KvMeta::default_instance())
    }
    pub fn clear_meta(&mut self) {
        self.meta.clear();
    }

    pub fn has_meta(&self) -> bool {
        self.meta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta(&mut self, v: KvMeta) {
        self.meta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_meta(&mut self) -> &mut KvMeta {
        if self.meta.is_none() {
            self.meta.set_default();
        }
        self.meta.as_mut().unwrap()
    }

    // Take field
    pub fn take_meta(&mut self) -> KvMeta {
        self.meta.take().unwrap_or_else(|| KvMeta::new())
    }

    // repeated .import_sstpb.KVMeta metas = 12;


    pub fn get_metas(&self) -> &[KvMeta] {
        &self.metas
    }
    pub fn clear_metas(&mut self) {
        self.metas.clear();
    }

    // Param is passed by value, moved
    pub fn set_metas(&mut self, v: ::protobuf::RepeatedField<KvMeta>) {
        self.metas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metas(&mut self) -> &mut ::protobuf::RepeatedField<KvMeta> {
        &mut self.metas
    }

    // Take field
    pub fn take_metas(&mut self) -> ::protobuf::RepeatedField<KvMeta> {
        ::std::mem::replace(&mut self.metas, ::protobuf::RepeatedField::new())
    }

    // .import_sstpb.RewriteRule rewrite_rule = 2;


    pub fn get_rewrite_rule(&self) -> &RewriteRule {
        self.rewrite_rule.as_ref().unwrap_or_else(|| RewriteRule::default_instance())
    }
    pub fn clear_rewrite_rule(&mut self) {
        self.rewrite_rule.clear();
    }

    pub fn has_rewrite_rule(&self) -> bool {
        self.rewrite_rule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rewrite_rule(&mut self, v: RewriteRule) {
        self.rewrite_rule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rewrite_rule(&mut self) -> &mut RewriteRule {
        if self.rewrite_rule.is_none() {
            self.rewrite_rule.set_default();
        }
        self.rewrite_rule.as_mut().unwrap()
    }

    // Take field
    pub fn take_rewrite_rule(&mut self) -> RewriteRule {
        self.rewrite_rule.take().unwrap_or_else(|| RewriteRule::new())
    }

    // repeated .import_sstpb.RewriteRule rewrite_rules = 13;


    pub fn get_rewrite_rules(&self) -> &[RewriteRule] {
        &self.rewrite_rules
    }
    pub fn clear_rewrite_rules(&mut self) {
        self.rewrite_rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rewrite_rules(&mut self, v: ::protobuf::RepeatedField<RewriteRule>) {
        self.rewrite_rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rewrite_rules(&mut self) -> &mut ::protobuf::RepeatedField<RewriteRule> {
        &mut self.rewrite_rules
    }

    // Take field
    pub fn take_rewrite_rules(&mut self) -> ::protobuf::RepeatedField<RewriteRule> {
        ::std::mem::replace(&mut self.rewrite_rules, ::protobuf::RepeatedField::new())
    }

    // string storage_cache_id = 5;


    pub fn get_storage_cache_id(&self) -> &str {
        &self.storage_cache_id
    }
    pub fn clear_storage_cache_id(&mut self) {
        self.storage_cache_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage_cache_id(&mut self, v: ::std::string::String) {
        self.storage_cache_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage_cache_id(&mut self) -> &mut ::std::string::String {
        &mut self.storage_cache_id
    }

    // Take field
    pub fn take_storage_cache_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.storage_cache_id, ::std::string::String::new())
    }

    // .backup.StorageBackend storage_backend = 3;


    pub fn get_storage_backend(&self) -> &super::brpb::StorageBackend {
        self.storage_backend.as_ref().unwrap_or_else(|| super::brpb::StorageBackend::default_instance())
    }
    pub fn clear_storage_backend(&mut self) {
        self.storage_backend.clear();
    }

    pub fn has_storage_backend(&self) -> bool {
        self.storage_backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage_backend(&mut self, v: super::brpb::StorageBackend) {
        self.storage_backend = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage_backend(&mut self) -> &mut super::brpb::StorageBackend {
        if self.storage_backend.is_none() {
            self.storage_backend.set_default();
        }
        self.storage_backend.as_mut().unwrap()
    }

    // Take field
    pub fn take_storage_backend(&mut self) -> super::brpb::StorageBackend {
        self.storage_backend.take().unwrap_or_else(|| super::brpb::StorageBackend::new())
    }

    // .kvrpcpb.Context context = 4;


    pub fn get_context(&self) -> &super::kvrpcpb::Context {
        self.context.as_ref().unwrap_or_else(|| super::kvrpcpb::Context::default_instance())
    }
    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: super::kvrpcpb::Context) {
        self.context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut super::kvrpcpb::Context {
        if self.context.is_none() {
            self.context.set_default();
        }
        self.context.as_mut().unwrap()
    }

    // Take field
    pub fn take_context(&mut self) -> super::kvrpcpb::Context {
        self.context.take().unwrap_or_else(|| super::kvrpcpb::Context::new())
    }

    // .backup.CipherInfo cipher_info = 11;


    pub fn get_cipher_info(&self) -> &super::brpb::CipherInfo {
        self.cipher_info.as_ref().unwrap_or_else(|| super::brpb::CipherInfo::default_instance())
    }
    pub fn clear_cipher_info(&mut self) {
        self.cipher_info.clear();
    }

    pub fn has_cipher_info(&self) -> bool {
        self.cipher_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cipher_info(&mut self, v: super::brpb::CipherInfo) {
        self.cipher_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cipher_info(&mut self) -> &mut super::brpb::CipherInfo {
        if self.cipher_info.is_none() {
            self.cipher_info.set_default();
        }
        self.cipher_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_cipher_info(&mut self) -> super::brpb::CipherInfo {
        self.cipher_info.take().unwrap_or_else(|| super::brpb::CipherInfo::new())
    }
}

impl ::protobuf::Message for ApplyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.meta {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metas {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rewrite_rule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rewrite_rules {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storage_backend {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cipher_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.meta)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.metas)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rewrite_rule)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rewrite_rules)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.storage_cache_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storage_backend)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.context)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cipher_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.metas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.rewrite_rule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.rewrite_rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.storage_cache_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.storage_cache_id);
        }
        if let Some(ref v) = self.storage_backend.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cipher_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.meta.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.metas {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.rewrite_rule.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.rewrite_rules {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.storage_cache_id.is_empty() {
            os.write_string(5, &self.storage_cache_id)?;
        }
        if let Some(ref v) = self.storage_backend.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.context.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cipher_info.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplyRequest {
        ApplyRequest::new()
    }

    fn default_instance() -> &'static ApplyRequest {
        static mut instance: ::protobuf::lazy::Lazy<ApplyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ApplyRequest,
        };
        unsafe {
            instance.get(ApplyRequest::new)
        }
    }
}

impl ::protobuf::Clear for ApplyRequest {
    fn clear(&mut self) {
        self.meta.clear();
        self.metas.clear();
        self.rewrite_rule.clear();
        self.rewrite_rules.clear();
        self.storage_cache_id.clear();
        self.storage_backend.clear();
        self.context.clear();
        self.cipher_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ApplyRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.meta, "meta", buf);
        ::protobuf::PbPrint::fmt(&self.metas, "metas", buf);
        ::protobuf::PbPrint::fmt(&self.rewrite_rule, "rewrite_rule", buf);
        ::protobuf::PbPrint::fmt(&self.rewrite_rules, "rewrite_rules", buf);
        ::protobuf::PbPrint::fmt(&self.storage_cache_id, "storage_cache_id", buf);
        ::protobuf::PbPrint::fmt(&self.storage_backend, "storage_backend", buf);
        ::protobuf::PbPrint::fmt(&self.context, "context", buf);
        ::protobuf::PbPrint::fmt(&self.cipher_info, "cipher_info", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ApplyRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.meta, "meta", &mut s);
        ::protobuf::PbPrint::fmt(&self.metas, "metas", &mut s);
        ::protobuf::PbPrint::fmt(&self.rewrite_rule, "rewrite_rule", &mut s);
        ::protobuf::PbPrint::fmt(&self.rewrite_rules, "rewrite_rules", &mut s);
        ::protobuf::PbPrint::fmt(&self.storage_cache_id, "storage_cache_id", &mut s);
        ::protobuf::PbPrint::fmt(&self.storage_backend, "storage_backend", &mut s);
        ::protobuf::PbPrint::fmt(&self.context, "context", &mut s);
        ::protobuf::PbPrint::fmt(&self.cipher_info, "cipher_info", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplyResponse {
    // message fields
    pub range: ::protobuf::SingularPtrField<Range>,
    pub error: ::protobuf::SingularPtrField<Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplyResponse {
    fn default() -> &'a ApplyResponse {
        <ApplyResponse as ::protobuf::Message>::default_instance()
    }
}

impl ApplyResponse {
    pub fn new() -> ApplyResponse {
        ::std::default::Default::default()
    }

    // .import_sstpb.Range range = 1;


    pub fn get_range(&self) -> &Range {
        self.range.as_ref().unwrap_or_else(|| Range::default_instance())
    }
    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: Range) {
        self.range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&mut self) -> &mut Range {
        if self.range.is_none() {
            self.range.set_default();
        }
        self.range.as_mut().unwrap()
    }

    // Take field
    pub fn take_range(&mut self) -> Range {
        self.range.take().unwrap_or_else(|| Range::new())
    }

    // .import_sstpb.Error error = 2;


    pub fn get_error(&self) -> &Error {
        self.error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        self.error.take().unwrap_or_else(|| Error::new())
    }
}

impl ::protobuf::Message for ApplyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.range {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.range)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.range.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplyResponse {
        ApplyResponse::new()
    }

    fn default_instance() -> &'static ApplyResponse {
        static mut instance: ::protobuf::lazy::Lazy<ApplyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ApplyResponse,
        };
        unsafe {
            instance.get(ApplyResponse::new)
        }
    }
}

impl ::protobuf::Clear for ApplyResponse {
    fn clear(&mut self) {
        self.range.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ApplyResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.range, "range", buf);
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ApplyResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.range, "range", &mut s);
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClearRequest {
    // message fields
    pub prefix: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClearRequest {
    fn default() -> &'a ClearRequest {
        <ClearRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClearRequest {
    pub fn new() -> ClearRequest {
        ::std::default::Default::default()
    }

    // string prefix = 1;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClearRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_string(1, &self.prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClearRequest {
        ClearRequest::new()
    }

    fn default_instance() -> &'static ClearRequest {
        static mut instance: ::protobuf::lazy::Lazy<ClearRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClearRequest,
        };
        unsafe {
            instance.get(ClearRequest::new)
        }
    }
}

impl ::protobuf::Clear for ClearRequest {
    fn clear(&mut self) {
        self.prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ClearRequest {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.prefix, "prefix", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ClearRequest {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.prefix, "prefix", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClearResponse {
    // message fields
    pub error: ::protobuf::SingularPtrField<Error>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClearResponse {
    fn default() -> &'a ClearResponse {
        <ClearResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClearResponse {
    pub fn new() -> ClearResponse {
        ::std::default::Default::default()
    }

    // .import_sstpb.Error error = 1;


    pub fn get_error(&self) -> &Error {
        self.error.as_ref().unwrap_or_else(|| Error::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        self.error.take().unwrap_or_else(|| Error::new())
    }
}

impl ::protobuf::Message for ClearResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClearResponse {
        ClearResponse::new()
    }

    fn default_instance() -> &'static ClearResponse {
        static mut instance: ::protobuf::lazy::Lazy<ClearResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClearResponse,
        };
        unsafe {
            instance.get(ClearResponse::new)
        }
    }
}

impl ::protobuf::Clear for ClearResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::PbPrint for ClearResponse {
    #[allow(unused_variables)]
    fn fmt(&self, name: &str, buf: &mut String) {
        ::protobuf::push_message_start(name, buf);
        let old_len = buf.len();
        ::protobuf::PbPrint::fmt(&self.error, "error", buf);
        if old_len < buf.len() {
          buf.push(' ');
        }
        buf.push('}');
    }
}
impl ::std::fmt::Debug for ClearResponse {
    #[allow(unused_variables)]
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        let mut s = String::new();
        ::protobuf::PbPrint::fmt(&self.error, "error", &mut s);
        write!(f, "{}", s)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SwitchMode {
    Normal = 0,
    Import = 1,
}

impl ::protobuf::ProtobufEnum for SwitchMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SwitchMode> {
        match value {
            0 => ::std::option::Option::Some(SwitchMode::Normal),
            1 => ::std::option::Option::Some(SwitchMode::Import),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SwitchMode] = &[
            SwitchMode::Normal,
            SwitchMode::Import,
        ];
        values
    }
}

impl ::std::marker::Copy for SwitchMode {
}

impl ::protobuf::PbPrint for SwitchMode {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == SwitchMode::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for SwitchMode {
    fn default() -> Self {
        SwitchMode::Normal
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchMode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DownloadRequestType {
    Legacy = 0,
    Keyspace = 1,
}

impl ::protobuf::ProtobufEnum for DownloadRequestType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DownloadRequestType> {
        match value {
            0 => ::std::option::Option::Some(DownloadRequestType::Legacy),
            1 => ::std::option::Option::Some(DownloadRequestType::Keyspace),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DownloadRequestType] = &[
            DownloadRequestType::Legacy,
            DownloadRequestType::Keyspace,
        ];
        values
    }
}

impl ::std::marker::Copy for DownloadRequestType {
}

impl ::protobuf::PbPrint for DownloadRequestType {
    fn fmt(&self, name: &str, buf: &mut String) {
        use std::fmt::Write;
        if *self == DownloadRequestType::default() {
            return;
        }
        ::protobuf::push_field_start(name, buf);
        write!(buf, "{:?}", self).unwrap();
    }
}

impl ::std::default::Default for DownloadRequestType {
    fn default() -> Self {
        DownloadRequestType::Legacy
    }
}

impl ::protobuf::reflect::ProtobufValue for DownloadRequestType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}
pub use super::import_sstpb_grpc::*;
